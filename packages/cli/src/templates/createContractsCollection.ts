import { writeFileSync } from 'fs'
import { join } from 'path'

import { RUNNING_DIRECTORY } from '../utils/constants.js'
import touchDirectory from '../utils/touchDir.js'
import generateContractTypes from '../utils/generateTypes.js'

function createContractFile(contract: ContractConfig & { contractName: string }) {
  if (!contract.abi) {
    throw new Error('ABI not fetched')
  }

  const readMethods = contract.abi
    .filter((a) => a.type === 'function' && (a.stateMutability === 'pure' || a.stateMutability === 'view'))
    .reduce((acc, a) => {
      if (acc.includes(a.name)) return acc
      return [...acc, a.name]
    }, [] as string[])

  const hasRead = !!readMethods.length

  const writeMethods = contract.abi
    .filter((a) => a.type === 'function' && (a.stateMutability === 'nonpayable' || a.stateMutability === 'payable'))
    .reduce((acc, a) => {
      if (acc.includes(a.name)) return acc
      return [...acc, a.name]
    }, [] as string[])

  const hasWrite = !!writeMethods.length

  const content = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

${hasRead || hasWrite ? `import { ExtractArgs } from '@dappql/react'` : ''}
import { Address } from 'viem'

export const abi = ${JSON.stringify(contract.abi, undefined, 4)} as const

export const deployAddress: Address | undefined = ${contract.address ? `'${contract.address}'` : 'undefined'}

${generateContractTypes(contract.abi)}
${
  hasRead
    ? `
export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: '{{CONTRACT_NAME}}'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: {
    contractAddress?: Address
    defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
  }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
  | Address
  | {
    contractAddress?: Address
    defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
    },
  ): Request<M> {
    const address =
      typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
    const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

    const call = {
      contractName: '{{CONTRACT_NAME}}' as const,
      method,
      args,
      address,
      deployAddress,
      defaultValue,
      getAbi: () => abi,
      with: (options: {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      }) => {
          call.address = options.contractAddress
          call.defaultValue = options.defaultValue
          return call as Request<M>
      },
      defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
        call.defaultValue = defaultValue
        return call as Request<M>
      },
      at: (address: Address) => {
        call.address = address
        return call as Request<M>
      },
    } as Request<M>

    return call
}

type CallType = {
  [K in Calls]: (
    ...args: ExtractArgs<Contract['calls'][K]>
  ) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
${readMethods.map((m) => `\t\t${m}: (...args: ExtractArgs<Contract['calls']['${m}']>) => getRequest('${m}', args),`).join('\n')}
}
`
    : ''
}
${
  hasWrite
    ? `
export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: '{{CONTRACT_NAME}}' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation:  {
  [K in Mutations]: {
    contractName: '{{CONTRACT_NAME}}'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
${writeMethods.map((m) => `\t\t${m}: getMutation('${m}'),`).join('\n')}
}
`
    : ''
}
`.replaceAll('{{CONTRACT_NAME}}', contract.contractName)

  return { content, hasRead, hasWrite }
}

export default function createContractsCollection(
  contracts: (ContractConfig & { contractName: string })[],
  target: string,
  isModule?: boolean,
) {
  const collectionPath = join(RUNNING_DIRECTORY, target)
  touchDirectory(collectionPath)

  const generated = contracts.map((c) => {
    const contractPath = join(collectionPath, `${c.contractName}.ts`)
    const { hasRead, hasWrite, content } = createContractFile(c)
    writeFileSync(contractPath, content)
    return { hasRead, hasWrite, ...c }
  })

  const collectionIndex = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */
  
${generated.map((c) => `export * as ${c.contractName} from './${c.contractName}${isModule ? '.js' : ''}'`).join('\n')}
`

  writeFileSync(join(collectionPath, 'index.ts'), collectionIndex)
}
