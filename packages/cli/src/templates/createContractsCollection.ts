import { writeFileSync } from 'fs'
import { join } from 'path'

import { RUNNING_DIRECTORY } from '../utils/constants'
import touchDirectory from '../utils/touchDir'
import generateContractTypes from '../utils/generateTypes'

function createContractFile(contract: ContractConfig & { contractName: string }) {
  if (!contract.abi) {
    throw new Error('ABI not fetched')
  }

  const readMethods = contract.abi
    .filter((a) => a.type === 'function' && (a.stateMutability === 'pure' || a.stateMutability === 'view'))
    .reduce((acc, a) => {
      if (acc.includes(a.name)) return acc
      return [...acc, a.name]
    }, [] as string[])

  const hasRead = !!readMethods.length

  const hasWrite = !!contract.abi.find(
    (a) => a.type === 'function' && (a.stateMutability === 'nonpayable' || a.stateMutability === 'payable'),
  )

  const content = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

${hasRead || hasWrite ? `import { ExtractArgs } from '@dappql/core'` : ''}
import { Address, Client, getContract } from 'viem'

const abi = ${JSON.stringify(contract.abi, undefined, 4)} as const

const deployAddress: Address | undefined = ${contract.address ? `'${contract.address}'` : 'undefined'}

const get{{CONTRACT_NAME}}Contract = (address: Address, client: Client) => getContract({ client, abi, address })
${generateContractTypes(contract.contractName, contract.abi)}
${
  hasRead
    ? `
export type {{CONTRACT_NAME}}ContractQueries = keyof {{CONTRACT_NAME}}Contract['calls']
export function {{CONTRACT_NAME}}Call<M extends {{CONTRACT_NAME}}ContractQueries>(
  method: M,
  args: ExtractArgs<{{CONTRACT_NAME}}Contract['calls'][M]>,
  contractAddressOrOptions?:
  | Address
  | {
    contractAddress?: Address
    defaultValue?: Awaited<ReturnType<{{CONTRACT_NAME}}Contract['calls'][M]>>
    },
  ) {
    const address =
      typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
    const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

    const call = {
      contractName: '{{CONTRACT_NAME}}' as const,
      method,
      args,
      address,
      deployAddress,
      defaultValue,
      getAbi: () => abi,
      with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<{{CONTRACT_NAME}}Contract['calls'][M]>> }) => {
        call.address = options.contractAddress
        call.defaultValue = options.defaultValue
        return call
      }
    }

    return call
}`
    : ''
}
${
  hasWrite
    ? `
export type {{CONTRACT_NAME}}ContractMutations = keyof {{CONTRACT_NAME}}Contract['mutations']
export function {{CONTRACT_NAME}}Mutation<M extends {{CONTRACT_NAME}}ContractMutations>(functionName: M) {
  return {
    contractName: '{{CONTRACT_NAME}}' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<{{CONTRACT_NAME}}Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}`
    : ''
}

const {{CONTRACT_NAME}} = {
  deployAddress,
  abi,
  getContract: get{{CONTRACT_NAME}}Contract,
  ${
    hasRead
      ? `call: {
${readMethods.map((m) => `\t\t${m}: (...args: ExtractArgs<{{CONTRACT_NAME}}Contract['calls']['${m}']>) => {{CONTRACT_NAME}}Call('${m}', args),`).join('\n')}
  },`
      : ''
  }
  ${hasWrite ? 'mutation: {{CONTRACT_NAME}}Mutation,' : ''}
}

export default {{CONTRACT_NAME}}
`.replaceAll('{{CONTRACT_NAME}}', contract.contractName)

  return { content, hasRead, hasWrite }
}

export default function createContractsCollection(
  contracts: (ContractConfig & { contractName: string })[],
  target: string,
) {
  const collectionPath = join(RUNNING_DIRECTORY, target)
  touchDirectory(collectionPath)

  const generated = contracts.map((c) => {
    const contractPath = join(collectionPath, `${c.contractName}.ts`)
    const { hasRead, hasWrite, content } = createContractFile(c)
    writeFileSync(contractPath, content)
    return { hasRead, hasWrite, ...c }
  })

  const collectionIndex = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */
  
${generated.map((c) => `export { default as ${c.contractName} } from './${c.contractName}'`).join('\n')}
`

  writeFileSync(join(collectionPath, 'index.ts'), collectionIndex)
}
