import { writeFileSync } from 'fs'
import { join } from 'path'

import { RUNNING_DIRECTORY } from '../utils/constants'
import touchDirectory from '../utils/touchDir'

function createContractFile(contract: ContractConfig & { contractName: string }) {
  if (!contract.abi) {
    throw new Error('ABI not fetched')
  }
  const hasRead = !!contract.abi.find(
    (a) => a.type === 'function' && (a.stateMutability === 'pure' || a.stateMutability === 'view'),
  )
  const hasWrite = !!contract.abi.find(
    (a) => a.type === 'function' && (a.stateMutability === 'nonpayable' || a.stateMutability === 'payable'),
  )

  const content = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

${hasRead || hasWrite ? `import { ${hasRead ? 'ExtractCallArgs' : ''}${hasRead && hasWrite ? ', ' : ''}${hasWrite ? 'ExtractMutationArgs' : ''} } from '@dappql/core'` : ''}
import { Address, Client, getContract } from 'viem'

const abi = ${JSON.stringify(contract.abi, undefined, 4)} as const

const deployAddress: Address | undefined = ${contract.address ? `'${contract.address}'` : 'undefined'}

const get{{CONTRACT_NAME}}Contract = (address: Address, client: Client) => getContract({ client, abi, address })
export type {{CONTRACT_NAME}}Contract = ReturnType<typeof get{{CONTRACT_NAME}}Contract>
${
  hasRead
    ? `
export type {{CONTRACT_NAME}}ContractQueries = keyof {{CONTRACT_NAME}}Contract['read']
export function {{CONTRACT_NAME}}Call<M extends {{CONTRACT_NAME}}ContractQueries>(
  method: M,
  args: ExtractCallArgs<{{CONTRACT_NAME}}Contract['read'][M]>,
  contractAddressOrOptions?:
  | Address
  | {
    contractAddress?: Address
    defaultValue?: Awaited<ReturnType<{{CONTRACT_NAME}}Contract['read'][M]>>
    },
  ) {
    const address =
      typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
    const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue
    
    return {
      contractName: '{{CONTRACT_NAME}}' as const,
      method,
      args,
      address,
      deployAddress,
      defaultValue,
      getAbi: () => abi,
    }
}`
    : ''
}
${
  hasWrite
    ? `
export type {{CONTRACT_NAME}}ContractMutations = keyof {{CONTRACT_NAME}}Contract['write']
export function {{CONTRACT_NAME}}Mutation<M extends {{CONTRACT_NAME}}ContractMutations>(functionName: M) {
  return {
    contractName: '{{CONTRACT_NAME}}' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractMutationArgs<{{CONTRACT_NAME}}Contract['write'][M]> | undefined,
    getAbi: () => abi,
  }
}`
    : ''
}

const {{CONTRACT_NAME}} = {
  deployAddress,
  abi,
  getContract: get{{CONTRACT_NAME}}Contract,
  ${hasRead ? 'call: {{CONTRACT_NAME}}Call,' : ''}
  ${hasWrite ? 'mutation: {{CONTRACT_NAME}}Mutation,' : ''}
}

export default {{CONTRACT_NAME}}
`.replaceAll('{{CONTRACT_NAME}}', contract.contractName)

  return { content, hasRead, hasWrite }
}

export default function createContractsCollection(
  contracts: (ContractConfig & { contractName: string })[],
  target: string,
) {
  const collectionPath = join(RUNNING_DIRECTORY, target, 'collection')
  touchDirectory(collectionPath)

  const generated = contracts.map((c) => {
    const contractPath = join(collectionPath, `${c.contractName}.ts`)
    const { hasRead, hasWrite, content } = createContractFile(c)
    writeFileSync(contractPath, content)
    return { hasRead, hasWrite, ...c }
  })

  const calls = generated.filter((c) => c.hasRead)
  const mutations = generated.filter((c) => c.hasWrite)

  const index = `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

export { useMasterQuery as useQuery, useIteratorQuery } from '@dappql/core'
import { MutationOptions, useMasterMutation } from '@dappql/core'

${generated.map((c) => `import ${c.contractName} from './${c.contractName}'`).join('\n')}

const CONTRACTS = {
  ${generated.map((c) => c.contractName).join(',\n\t')}
} as const

export type Contracts = typeof CONTRACTS

export const calls = {
  ${calls.map((c) => `${c.contractName}: ${c.contractName}.call`).join(',\n\t')}
} as const

export const mutations = {
  ${mutations.map((c) => `${c.contractName}: ${c.contractName}.mutation`).join(',\n\t')}
} as const

export function useMutation<C extends keyof typeof mutations, M extends Parameters<(typeof mutations)[C]>[0]>(
  contract: C,
  method: M,
  options?: MutationOptions,
) {
  // @ts-ignore -- TODO: Fix the contract method not callable TS issue
  return useMasterMutation(mutations[contract](method), options)
}
`
  writeFileSync(join(collectionPath, 'index.ts'), index)
}
